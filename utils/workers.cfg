#textdomain wesnoth-Wild_Frontiers
# This collection of macros all pertains to the mechanics of Peasant
# Worker units starting, stopping, and finishing projects. No details
# regarding the specific projects are included in this file.


# ----- Allow working ----------------------------------------------------
#define WORKERS_CAN_WORK
# Create menu items, create project types, Remove movement from all busy
# workers, update the project queue, and kill off projects if the workers
# are attacked. Called at the beginning of every scenario.

	{SET_BUILD_MENUS}		# see build_menus.cfg for details
	{SET_PROJECT_TYPES}		# see projects.cfg for details

	[event]
		name=side 1 turn refresh
		id=refresh_workers
		first_time_only=no
		{MODIFY_UNIT ({FILTER_FOR_WORKER}) moves 0}
		{MODIFY_UNIT ({FILTER_FOR_WORKER}) resting no}
		{MODIFY_UNIT ({FILTER_FOR_WORKER}) attacks_left 0}
	[/event]

	# Create event to update project progress each turn
	[event]
		name="side 1 turn"
		id=project_queue
		first_time_only=no
		# First decrement the number of turns for each project, then check if
		# any project is done.
		{VARIABLE x1_bak $x1}
		{VARIABLE y1_bak $y1}
		[for]
			array=projects.proj_list
			reverse=yes
			[do]
			{VARIABLE_OP projects.proj_list[$i].turns add -1}
			[if]
				{VARIABLE_CONDITIONAL projects.proj_list[$i].turns less_than_equal_to 0}
				[then]	# workers are now idle, build
					{REMOVE_UNIT_VARIABLE $projects.proj_list[$i].x $projects.proj_list[$i].y worker}
					{VARIABLE x1 $projects.proj_list[$i].x}
					{VARIABLE y1 $projects.proj_list[$i].y}
					{WF_CALL_FUNCTION $projects.proj_list[$i].goal do,custom,x,y=$projects.proj_list[$i].do,$projects.proj_list[$i].custom,$projects.proj_list[$i].x,$projects.proj_list[$i].y}
				[/then]
				[else]
					{SCROLL_TO $projects.proj_list[$i].x $projects.proj_list[$i].y}
					[floating_text]
						x=$projects.proj_list[$i].x
						y=$projects.proj_list[$i].y
						text=_"$projects.proj_list[$i].turns left"
					[/floating_text]
					#[delay]
					#	time=500
					#[/delay]
				[/else]
			[/if]
			[/do]
		[/for]
		{VARIABLE x1 $x1_bak}
		{VARIABLE y1 $y1_bak}
		{CLEAR_VARIABLE x1_bak}
		{CLEAR_VARIABLE y1_bak}

		# Delete finished items in the project queue. This loop is down
		# backwards from the FOREACH macro to avoid un-checked projects
		# shifting as finished ones are deleted. Some unfinished projects
		# may be checked twice, but that's okay. Since this is a separate loop
		# from that above the turns remaining are not decremented twice.
		{VARIABLE i $projects.proj_list.length}
		{VARIABLE_OP i sub 1}	# last element in array has index length-1
		[while]
			{VARIABLE_CONDITIONAL i greater_than_equal_to 0}
			[do]
				[if]
					# hopefully <= should kill any projects that seem to randomly sneak through
					# from time to time
					{VARIABLE_CONDITIONAL projects.proj_list[$i].turns less_than_equal_to 0}
					[then]
						{CLEAR_VARIABLE projects.proj_list[$i]}
					[/then]
				[/if]
				{VARIABLE_OP i sub 1}
			[/do]
		[/while]
		{CLEAR_VARIABLE i}
	[/event]

	# Create event to stop projects if workers are attacked
	[event]
		name=attack
		id=worker_attacked
		first_time_only=no
		[filter_second]
			#side=1
			{FILTER_FOR_WORKER}
		[/filter_second]
		{SCROLL_TO $x2 $y2}
		{STOP_PROJECT $x2 $y2 VAR=disrupt_goal}
		{NARRATOR_SAYS _"The project $disrupt_goal| was disrupted."}
		{CLEAR_VARIABLE disrupt_goal}
	[/event]

	# Create menu item to check on or stop a project if requested
#	[set_menu_item]
#		id=project_status
#		description=_ "Project status..."
#		image="build_icon.png"
#		[show_if]
#			[have_unit]
#				x,y=$x1,$y1
#				{FILTER_FOR_WORKER}
#			[/have_unit]
#		[/show_if]
#		[command]
#		[for]
#			array=projects.proj_list
#			reverse=yes
#			[do]
#				[if]
#					[and]
#						{VARIABLE_CONDITIONAL projects.proj_list[$i].x numerical_equals $x1}
#						{VARIABLE_CONDITIONAL projects.proj_list[$i].y numerical_equals $y1}
#					[/and]
#					[then]	# this *should* only happen once
#						{VARIABLE i_this $i}
#					[/then]
#				[/if]
#			[/do]
#		[/for]
#			[message]
#				speaker=unit
#				message=_"We've got $projects.proj_list[$i_this].turns work shifts left until this $projects.proj_list[$i_this].do $projects.proj_list[$i_this].goal project is complete, milord."
#				[option]
#					label=_"Okay."
#					[command][/command]
#				[/option]
#				[option]
#					label=_"Stop working on this project."
#					[command]
#						# This is not the most efficient way to do this, but
#						# it makes the macros simpler
#						{STOP_PROJECT $x1 $y1}
#						{UNIT_SAYS _"'ave it your way, milord. We should be able ta recover most of the materials."}
#						{UNIT_SAYS _"Time ta pack it up, boys!."}
#					[/command]
#				[/option]
#			[/message]
#			{CLEAR_VARIABLE i_this}
#		[/command]
#	[/set_menu_item]
#enddef

#define STOP_PROJECT X Y
#arg VAR
dummy_var#endarg
	# Stop the project occurring at X,Y
	{VARIABLE x1_bak $x1}
	{VARIABLE y1_bak $y1}
	[for]
		array=projects.proj_list
		reverse=yes
		[do]
		[if]
			[and]
				{VARIABLE_CONDITIONAL projects.proj_list[$i].x numerical_equals {X}}
				{VARIABLE_CONDITIONAL projects.proj_list[$i].y numerical_equals {Y}}
			[/and]
			[then]
				{VARIABLE {VAR} $projects.proj_list[$i].goal}
				{VARIABLE x1 {X}}
				{VARIABLE y1 {Y}}
				{WF_CALL_FUNCTION $projects.proj_list[$i].goal do,x,y="stop",{X},{Y}}
				{REMOVE_UNIT_VARIABLE {X} {Y} worker}
				{CLEAR_VARIABLE projects.proj_list[$i]}
				#[break]
				#[/break]
				# The shifting this causes is irrelevant since there *should*
				# be only one project stopped per complete loop iteration
			[/then]
		[/if]
		[/do]
	[/for]
	{VARIABLE x1 $x1_bak}
	{VARIABLE y1 $y1_bak}
	{CLEAR_VARIABLE x1_bak}
	{CLEAR_VARIABLE y1_bak}
	{CLEAR_VARIABLE dummy_var}
#enddef

#define FILTER_FOR_WORKER
	#[filter_wml]
	#	[variables]
	#		worker=yes
	#	[/variables]
	#[/filter_wml]
	formula="wml_vars.worker=1"
#enddef

#define HAVE_IDLE_WORKERS X Y
	[have_unit]
		x,y={X},{Y}
		side=1
		type=Peasant Workers
		[not]
			{FILTER_FOR_WORKER}
		[/not]
	[/have_unit]
#enddef

#define HAVE_IDLE_CASTERS X Y
	[have_unit]
		x,y={X},{Y}
		side=1
		type={CASTER_LIST}
		[not]
			{FILTER_FOR_WORKER}
		[/not]
	[/have_unit]
#enddef

#define HAVE_IDLE_DESTROYERS X Y
	[have_unit]
		x,y={X},{Y}
		side=1
		type_adv_tree={DESTROYER_LIST}
		[not]
			{FILTER_FOR_WORKER}
		[/not]
	[/have_unit]
#enddef

#define HAVE_IDLE_RAISERS X Y
	[have_unit]
		x,y={X},{Y}
		side=1
		type_adv_tree={RAISER_LIST}
		[not]
			{FILTER_FOR_WORKER}
		[/not]
	[/have_unit]
#enddef

#define STOP_WINTER_PROJECTS
		# Stop projects (except tree-cutting) for the winter
		{VARIABLE ii "$($projects.proj_list.length-1)"}
		{WF_DEBUG "Stopping $ii projects for the winter"}
		[while]
			{VARIABLE_CONDITIONAL ii greater_than_equal_to 0}
			[do]
				[if]
					# These can currently continue into winter
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "plant trees"}
					[or]
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "cut forest"}
					[/or]
					[or]
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "drain swamp"}
					[/or]
					[or]
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "road"}
					[/or]
					[or]
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "rune"}
					[/or]
					[or]
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "mountain"}
					[/or]
					[or]
					{VARIABLE_CONDITIONAL projects.proj_list[$ii].goal equals "flatten hills"}
					[/or]
					[then]
						# do nothing
						{WF_DEBUG "Don't stop this project $projects.proj_list[$ii].goal"}
					[/then]
					[else]
						{SCROLL_TO $projects.proj_list[$ii].x $projects.proj_list[$ii].y}
						{WF_DEBUG "Stopping $projects.proj_list[$ii].x $projects.proj_list[$ii].y $projects.proj_list[$ii].goal"}
						{NARRATOR_SAYS _"The onset of winter storms forced these peasant workers to abandon their $projects.proj_list[$ii].goal project until spring."}
						# This macro handles idling and queue adjustment
						{STOP_PROJECT $projects.proj_list[$ii].x $projects.proj_list[$ii].y}
					[/else]
				[/if]
				{VARIABLE_OP ii sub 1}
			[/do]
		[/while]
		{CLEAR_VARIABLE ii}
#enddef
