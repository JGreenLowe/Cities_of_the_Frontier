#define BORDER
5#enddef

#define FIRE_EVENT NAME
	# Quick syntactic shortcut to fire an event. Used to call tutorial
	# messages and project events
	[fire_event]
		name={NAME}
	[/fire_event]
#enddef

#define FILTER_FOR_LEADER
        #[filter_wml]
        #       {IS_LEADER}
        #[/filter_wml]
        status=leader
        #formula="wml_vars.leader=1"
#enddef

#define NOT_FILTER
	#In a location filter, an empty [filter] tag means "match only locations with units on them", so an empty [filter] tag in a [not] tag inverts that to "match only locations with no unit on them". -- Celtic_Minstrel
	[not]
		[filter]
		[/filter]
	[/not]
#enddef

#define NOT_FILTER_ADJACENT
	[not]
		[filter_adjacent_location]
			[filter]
			[/filter]
		[/filter_adjacent_location]
	[/not]
#enddef

#define NOT_CENTER
	[and]
		{X_AND_Y_ARE_ON_THE_MAP}
	[/and]
	[and]
        [not]
            [and]
                x,y=$center_x,$center_y
                radius=3
            [/and]
        [/not]
	[/and]
#enddef

#define NOT_CENTER_Q1
	[and]
		{FIRST_QUARTER}
	[/and]
	[and]
        [not]
            [and]
                x,y=$center_x,$center_y
                radius=3
            [/and]
        [/not]
	[/and]
#enddef

#define NOT_CENTER_Q2
	[and]
		{SECOND_QUARTER}
	[/and]
	[and]
        [not]
            [and]
                x,y=$center_x,$center_y
                radius=3
            [/and]
        [/not]
	[/and]
#enddef

#define NOT_CENTER_Q3
	[and]
		{THIRD_QUARTER}
	[/and]
	[and]
        [not]
            [and]
                x,y=$center_x,$center_y
                radius=3
            [/and]
        [/not]
	[/and]
#enddef

#define NOT_CENTER_Q4
	[and]
		{FOURTH_QUARTER}
	[/and]
	[and]
        [not]
            [and]
                x,y=$center_x,$center_y
                radius=3
            [/and]
        [/not]
	[/and]
#enddef

#define FIRST_QUARTER
    include_borders=no
    x=5-$("$center_x| - 5")
    y=5-$("$center_y| - 5")
#enddef

#define SECOND_QUARTER
    include_borders=no
    x=$("$center_x| + 5")-$("{MAP_WIDTH} - 5")
    y=5-$("$center_y| - 5")
#enddef

#define THIRD_QUARTER
    include_borders=no
    x=5-$("$center_x| - 5")
    y=$("$center_y| + 5")-$("{MAP_HEIGHT} - 5")
#enddef

#define FOURTH_QUARTER
    include_borders=no
    x=$("$center_x| + 5")-$("{MAP_WIDTH} - 5")
    y=$("$center_y| + 5")-$("{MAP_HEIGHT} - 5")
#enddef

#define GEN_STORE_LOC_Q1
    [store_locations]
        variable=change_hex
        terrain=Gg
	{NOT_CENTER_Q1}
        [filter_adjacent_location]
            terrain=Gg
            count=6
        [/filter_adjacent_location]
    [/store_locations]
#enddef

#define GEN_STORE_LOC_Q2
    [store_locations]
        variable=change_hex
        terrain=Gg
	{NOT_CENTER_Q2}
        [filter_adjacent_location]
            terrain=Gg
            count=6
        [/filter_adjacent_location]
    [/store_locations]
#enddef

#define GEN_STORE_LOC_Q3
    [store_locations]
        variable=change_hex
        terrain=Gg
	{NOT_CENTER_Q3}
        [filter_adjacent_location]
            terrain=Gg
            count=6
        [/filter_adjacent_location]
    [/store_locations]
#enddef

#define GEN_STORE_LOC_Q4
    [store_locations]
        variable=change_hex
        terrain=Gg
	{NOT_CENTER_Q4}
        [filter_adjacent_location]
            terrain=Gg
            count=6
        [/filter_adjacent_location]
    [/store_locations]
#enddef

#define GEN_STORE_LOC
    [store_locations]
        variable=change_hex
        terrain=Gg
	{NOT_CENTER}
        [filter_adjacent_location]
            terrain=Gg
            count=6
        [/filter_adjacent_location]
    [/store_locations]
#enddef

# Lifted from: Genesis
#define WF_TERRAIN_ONE_IN OLDT ADJ NEWT ONEIN
    [store_locations]
        variable=change_hex
        terrain={OLDT}
        [filter_adjacent_location]
            terrain={ADJ}
        [/filter_adjacent_location]
    [/store_locations]
    [for]
        array=change_hex
        [do]
            [set_variable]
                name=change_terrain
                rand=1..{ONEIN}
            [/set_variable]
            [if]
                [variable]
                    name=change_terrain
                    numerical_equals=1
                [/variable]
                [then]
                    [terrain]
                        x,y=$change_hex[$i].x,$change_hex[$i].y
                        terrain={NEWT}
                    [/terrain]
                [/then]
            [/if]
            {CLEAR_VARIABLE change_terrain}
        [/do]
    [/for]
    {CLEAR_VARIABLE change_hex}
#enddef

#define WF_CONVERT_VERY_HOT MIN MAX TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MIN}
        max_height={MAX}
        min_temperature=0
        max_temperature=84
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define WF_CONVERT_HOT MIN MAX TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MIN}
        max_height={MAX}
        min_temperature=85
        max_temperature=184
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define WF_CONVERT_WARM MIN MAX TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MIN}
        max_height={MAX}
        min_temperature=185
        max_temperature=297
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define WF_CONVERT_COOL MIN MAX TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MIN}
        max_height={MAX}
        min_temperature=298
        max_temperature=464
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define WF_CONVERT_COLD MIN MAX TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MIN}
        max_height={MAX}
        min_temperature=465
        max_temperature=599
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define WF_CONVERT_VERY_COLD MIN MAX TERRAINLIST NEW_TERRAIN
    # Convert terrains to a terrain within the specified height and temp ranges.
    [convert]
        min_height={MIN}
        max_height={MAX}
        min_temperature=600
        max_temperature=1000
        from={TERRAINLIST}
        to={NEW_TERRAIN}
    [/convert]
#enddef

#define WF_CONVERT_MODERATE MIN MAX TERRAINLIST NEW_TERRAIN
    {WF_CONVERT_WARM {MIN} {MAX} {TERRAINLIST} {NEW_TERRAIN}}
    {WF_CONVERT_COOL {MIN} {MAX} {TERRAINLIST} {NEW_TERRAIN}}
#enddef

#define WF_ROAD_COST TERRAIN COST NEW
    [road_cost]
        terrain={TERRAIN}
        cost={COST}
        convert_to={NEW}
    [/road_cost]
#enddef

#define MIN_COST_ROAD TERRAIN
    [road_cost]
        terrain={TERRAIN}
        cost=2
        convert_to={TERRAIN}
    [/road_cost]
#enddef

#define HEIGHT_SET HEIGHT TERRAIN
    [height]
        height={HEIGHT}
        terrain={TERRAIN}
    [/height]
#enddef

#define ROAD_COST_LEAVE TERRAIN
	[road_cost]
		terrain={TERRAIN}
		cost=2
		convert_to={TERRAIN}
	[/road_cost]
#enddef

#define RANDOM_VAR VAR RANGE
    # I use lots of temporary random variables, so putting them all
    # in $random doesn't work for me. I promise to be good and clear them
    # when done
    [set_variable]
        name={VAR}
        rand={RANGE}
    [/set_variable]
#enddef

#define X_AND_Y_ARE_ON_THE_MAP
    # Require that x and y are on the map in a SLF. Otherwise the filter
    # can return 0 (i.e. on the map edge, not accessible).
    include_borders=no
    x=1-{MAP_WIDTH}
    y=1-{MAP_HEIGHT}
#enddef

#define FIND_SIGN_SITE_NEAR X Y DIR
    # store a sign site near a strip centered at X,Y in the variable map_signs
    # dir must be 'x' or 'y'
    {VARIABLE radius_x 0}
    {VARIABLE radius_y 0}
    [while]
        {VARIABLE_CONDITIONAL plains_store.length less_than 1}
        [do]
            [store_locations]
                variable=plains_store
                terrain=G*
                x="$({X}-$radius_x)"-"$({X}+$radius_x)"
                y="$({Y}-$radius_y)"-"$({Y}+$radius_y)"
            [/store_locations]
            {VARIABLE_OP radius_{DIR} add 1}
        [/do]
    [/while]
    {RANDOM_VAR rnd_i 0.."$($plains_store.length-1)"}
    [set_variables]
        name=map_signs
        mode=append
        [value]
            x=$plains_store[$rnd_i].x
            y=$plains_store[$rnd_i].y
            seen=no
        [/value]
    [/set_variables]
    {CLEAR_VARIABLE radius_x}
    {CLEAR_VARIABLE radius_y}
    {CLEAR_VARIABLE plains_store}
    {CLEAR_VARIABLE rnd_i}
#enddef

#define FIND_NEAREST_HEX VAR X Y FILTER
    # Stores the nearest hex to X,Y that matches the FILTER in the variable
    # named VAR. If there are multiple such hexes, pick a random one
    {VARIABLE radius 0}
    [while]
        [and]
            {VARIABLE_CONDITIONAL radius less_than "$(ceil(({MAP_HEIGHT}+{MAP_WIDTH})/2))"}
            {VARIABLE_CONDITIONAL hex_store.length less_than 1}
        [/and]
        [do]
            [store_locations]
                variable=hex_store
                include_borders=no
                {FILTER}
                [and]
                    x,y={X},{Y}
                    radius=$radius
                [/and]
            [/store_locations]
            {VARIABLE_OP radius add 1}
        [/do]
    [/while]
    [if]	# Check if I haven't yet found a viable hex
        {VARIABLE_CONDITIONAL hex_store.length less_than 1}
        [then]
            {ERROR "Could not find a location matching the provided filter: {FILTER}"}
            # Just pick a random location to allow the scenario to continue
            [store_locations]
                variable=hex_store
                {X_AND_Y_ARE_ON_THE_MAP}
            [/store_locations]
        [/then]
    [/if]
    {RANDOM_VAR rnd_i 0.."$($hex_store.length-1)"}
    [set_variables]
        name={VAR}
        to_variable=hex_store[$rnd_i]
    [/set_variables]
    {CLEAR_VARIABLE rnd_i,radius,hex_store}
#enddef

#define WF_DEBUG_LOCS
[event]
	name=start

	{CLEAR_VARIABLE debbie.count}
	{CLEAR_VARIABLE debbie.terra}
	{CLEAR_VARIABLE debbie}
	[store_locations]
		include_borders=no
		variable=locs_store
	[/store_locations]

	[foreach]
		array=locs_store
		[do]
			{LOOKUP_INDEX debbie.terra terrain $this_item.terrain debbie_index}
			[set_variable]
				name=debbie.terra[$debbie_index].terrain
				value=$this_item.terrain
			[/set_variable]
			{VARIABLE_OP debbie.terra[$debbie_index].count add 1}
			{CLEAR_VARIABLE debbie_index}
		[/do]
	[/foreach]
	{CLEAR_VARIABLE locs_store}

	{VARIABLE debbie_index 1}
	[foreach]
		array=debbie.terra
		[do]
			[terrain]
				x=2
				y=$debbie_index
				terrain=$this_item.terrain
			[/terrain]
			[label]
				x=2
				y=$debbie_index
				text="$this_item.terrain|: $this_item.count|"
			[/label]
			{VARIABLE_OP debbie_index add 1}
		[/do]
	[/foreach]
	{CLEAR_VARIABLE debbie_index}

#	[store_map_dimensions]
#		variable=store_map_dim
#	[/store_map_dimensions]
#	[store_locations]
#		terrain=!,Xu,Qxu
#		[not]
#			x=1-$store_map_dim.width
#			y=1-$store_map_dim.height
#		[/not]
#		variable=offmap_locs
#	[/store_locations]

	#{DEBUG_MSG "off $offmap_locs.length|"}

		#{CLEAR_VARIABLE offmap_locs}
		#{CLEAR_VARIABLE store_map_dim}

#	[store_gold]
#		variable=s_gold
#	[/store_gold]
#	{CLEAR_VARIABLE s_gold}
#
#	[store_unit_type_ids]
#		variable=s_unit_ids
#	[/store_unit_type_ids]
#	{CLEAR_VARIABLE s_unit_ids}
[/event]
#enddef

#define VALUE1 KEY1 ITEM1
	# syntactic shortcut to make a long array definition more compact
	[value]
		{KEY1}={ITEM1}
	[/value]
#enddef

#define VALUE2 KEY1 ITEM1 KEY2 ITEM2
	# syntactic shortcut to make a long array definition more compact
	[value]
		{KEY1}={ITEM1}
		{KEY2}={ITEM2}
	[/value]
#enddef
